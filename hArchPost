#!/usr/bin/env bash

# Harch UEFI/BIOS Automated Install (Hackers Arch)
# ---------------------------------------------------------------
# Author    : Chaotic_Guru                                       |
# Github    : https://github.com/ChaoticHackingNetwork           |
# Discord   : https://discord.gg/nv445EX (ChaoticHackingNetwork) |
# Version   : 0.1.3 						 |					 
# ---------------------------------------------------------------

GREEN='\033[0;32m'
RED='\033[0;31m'
WHITE='\033[0;37m'
YELLOW='\033[0;33m'
PURPLE='\033[0;35m'
RESET='\033[0m'
NEWLINE=$'\n'

greet() {
	echo -e "${PURPLE}Chaotic_Guru's hArch Installer${RESET}"
	echo ${NEWLINE}
	echo -e "${YELLOW}-> Simple${RESET}"
	echo -e "${GREEN}--> Quick${RESET}"
	echo -e "${WHITE}---> Efficient${RESET}"
	echo ${NEWLINE}
	echo -e ${YELLOW}
	echo ${NEWLINE}
	echo ${NEWLINE}
	echo " ██░ ██  ▄▄▄       ██▀███   ▄████▄   ██░ ██     ██▓     ██▓ ███▄    █  █    ██ ▒██   ██▒"
	echo "▓██░ ██▒▒████▄    ▓██ ▒ ██▒▒██▀ ▀█  ▓██░ ██▒   ▓██▒    ▓██▒ ██ ▀█   █  ██  ▓██▒▒▒ █ █ ▒░"
	echo "▒██▀▀██░▒██  ▀█▄  ▓██ ░▄█ ▒▒▓█    ▄ ▒██▀▀██░   ▒██░    ▒██▒▓██  ▀█ ██▒▓██  ▒██░░░  █   ░"
	echo "░▓█ ░██ ░██▄▄▄▄██ ▒██▀▀█▄  ▒▓▓▄ ▄██▒░▓█ ░██    ▒██░    ░██░▓██▒  ▐▌██▒▓▓█  ░██░ ░ █ █ ▒ "
	echo "░▓█▒░██▓ ▓█   ▓██▒░██▓ ▒██▒▒ ▓███▀ ░░▓█▒░██▓   ░██████▒░██░▒██░   ▓██░▒▒█████▓ ▒██▒ ▒██▒"
	echo " ▒ ░░▒░▒ ▒▒   ▓▒█░░ ▒▓ ░▒▓░░ ░▒ ▒  ░ ▒ ░░▒░▒   ░ ▒░▓  ░░▓  ░ ▒░   ▒ ▒ ░▒▓▒ ▒ ▒ ▒▒ ░ ░▓ ░"
	echo " ▒ ░▒░ ░  ▒   ▒▒ ░  ░▒ ░ ▒░  ░  ▒    ▒ ░▒░ ░   ░ ░ ▒  ░ ▒ ░░ ░░   ░ ▒░░░▒░ ░ ░ ░░   ░▒ ░"
	echo " ░  ░░ ░  ░   ▒     ░░   ░ ░         ░  ░░ ░     ░ ░    ▒ ░   ░   ░ ░  ░░░ ░ ░  ░    ░  "
	echo " ░  ░  ░      ░  ░   ░     ░ ░       ░  ░  ░       ░  ░ ░           ░    ░      ░    ░  "
	echo "                           ░                                                            "
	echo -e "${RESET}"
	echo ${NEWLINE}
	echo ${NEWLINE}
}

checkNet() {
	echo ${NEWLINE}
	echo ${NEWLINE}
	echo -e "[${YELLOW}INFO${RESET}] Checking Internet Connection...${NEWLINE}"
	if nc -zw2 archlinux.org 443
	then
  	echo -e "[${YELLOW}INFO${RESET}] Firing up Scripting Engines..."
	echo -e "[${YELLOW}INFO${RESET}] Enabling Parallel Downloads..."
	sed -i '/#ParallelDownloads/s/^#//g' /etc/pacman.conf
	echo -e "[${YELLOW}INFO${RESET}] Syncing time..."
	timedatectl set-ntp true
	else
	echo -e "[${RED}ERROR${RESET}] Check Internet connection, something went wrong"
	exit
	
	fi
}

installer() {
	echo ${NEWLINE}
	echo -e "[${GREEN}USER_INPUT${RESET}]"
	read -p "Hardened Kernel? [Y/n]: " kernel
	if [[ $kernel == 'y' ]] || [[ $kernel == 'Y' ]]
	then
	echo -e "[${YELLOW}INFO${RESET}] Installing base system...${NEWLINE}"
	pacstrap /mnt base base-devel linux-hardened linux-firmware linux-headers vim nano
	else
	echo ${NEWLINE}
	echo -e "[${YELLOW}INFO${RESET}] Installing base system...${NEWLINE}"
	pacstrap /mnt base base-devel linux linux-firmware linux-headers vim nano
	
	fi
	#Generate fstab
	genfstab -U /mnt >> /mnt/etc/fstab
}

partition_and_encrypt() {
	  echo -e "${GREEN}[*] Partitioning and encrypting the disk...${RESET}"
	  read -ep "Enter your SSD device path [Default: /dev/nvme0n1]: " dev_path

	  # Set default value if dev_path is empty
	  if [[ -z "$dev_path" ]]; then
	    dev_path="/dev/nvme0n1"
	  fi

	  if [[ ! -b "$dev_path" ]]; then
	    echo "Invalid device path. Please provide a valid SSD device path."
	    exit 1
	  fi

	  echo -e "${GREEN}[*] Creating partitions on $dev_path...${RESET}"
	  if ! parted --script "$dev_path" mklabel gpt mkpart ESP fat32 1MiB 512MiB set 1 boot on mkpart primary 512MiB 100%; then
	    echo "Failed to create partitions on $dev_path. Please check your system configuration and try again."
	    exit 1
	  fi

	  echo -e "${GREEN}[*] Formatting the ESP partition...${RESET}"
	  if ! mkfs.fat -F32 "${dev_path}p1"; then
	    echo "Failed to format the ESP partition. Please check your system configuration and try again."
	    exit 1
	  fi

	  echo -e "${GREEN}[*] Creating LUKS container on ${dev_path}p2...${RESET}"
	  if ! cryptsetup luksFormat --type luks2 --hash sha512 --key-size 512 --iter-time 5000 --pbkdf argon2id --cipher aes-xts-plain64 "${dev_path}p2"; then
	    echo "Failed to create LUKS container on ${dev_path}p2. Please check your system configuration and try again."
	    exit 1
	  fi

	  echo -e "${GREEN}[*] Opening LUKS container on ${dev_path}p2 as cryptroot...${RESET}"
	  if ! cryptsetup open --type luks "${dev_path}p2" cryptroot; then
	    echo "Failed to open LUKS container on ${dev_path}p2. Please check your system configuration and try again."
	    exit 1
	  fi

	  echo -e "${GREEN}[*] Verifying the device mapping for encryption...${RESET}"
	  if ! cryptsetup status cryptroot; then
	    echo "Failed to verify the device mapping for encryption. Please check your system configuration and try again."
	    exit 1
	  fi

	  echo -e "${GREEN}[*] Adding encryption key to cryptroot...${RESET}"
	  if ! { echo "$encryption_password"; echo "$encryption_password"; echo "$encryption_password"; } | cryptsetup luksAddKey "${dev_path}p2" -; then
	    echo "Failed to add encryption key to cryptroot. Please check your system configuration and try again."
	    exit 1
	  fi

	  echo -e "${GREEN}[*] Filling encrypted partition with random data...${RESET}"
	  random_data_file="/tmp/random_data"
	  chunk_size="10M"
	  # Get the size of the encrypted partition
	  total_size=$(blockdev --getsize64 /dev/mapper/cryptroot)

	if [[ -z "$total_size" ]]; then
		echo "Failed to retrieve the size of the encrypted partition. Please check your system configuration."
		exit 1
	fi

	chunk_size_bytes=$((1024 * 1024 * ${chunk_size%[A-Z]*}))
	total_chunks=$(( (total_size + chunk_size_bytes - 1) / chunk_size_bytes ))

	for ((i = 0; i < total_chunks; i++)); do
	  dd if=/dev/urandom of="$random_data_file" bs="$chunk_size" count=1 status=none
	  dd if="$random_data_file" of=/dev/mapper/cryptroot bs="$chunk_size" status=none
	done

	rm "$random_data_file"

	echo -e "${GREEN}[*] Encrypted partition filled with random data successfully.${RESET}"

	echo -e "${GREEN}[*] Formatting encrypted partition to Btrfs filesystem...${RESET}"
	if mkfs.btrfs /dev/mapper/cryptroot; then
	  echo -e "${GREEN}[+] Encrypted partition formatted to Btrfs filesystem successfully.${RESET}"
	else
	  echo "Failed to format encrypted partition to Btrfs filesystem. Please check your system configuration and try again."
	  read -p "Press 'e' to exit or any other key to continue: " choice
	  if [[ "$choice" == "e" ]]; then
	    exit 1
	  fi
	fi
}

getDrive() {
    echo ${NEWLINE}
    echo ${NEWLINE}
    echo -e "[${YELLOW}INFO${RESET}] Gathering drives...${NEWLINE}"
    lsblk -f
    echo -e "[${GREEN}USER_INPUT${RESET}]"
    echo "Syntax: /dev/sda or /dev/nvme0n1"
    read -p "Enter Drive to prepare: " drive
    read -p "Do you want too add Disk encryption [y/n]: " diskEncrypt
    read -p "Do you want to manually partition [y/n]: " manual
    if [[ $manual == 'y' ]] || [[ $manual == 'Y' ]]; then
        cfdisk $drive
        echo -e "[${YELLOW}INFO${RESET}] Entering BASH shell..."
        echo -e "[${YELLOW}INFO${RESET}] Make your filesystem and mount /mnt..."
        echo -e "[${YELLOW}INFO${RESET}] Type ${GREEN}exit${RESET} once finished..."
        bash
    else
        echo ${NEWLINE}
        echo ${NEWLINE}
        echo -e "[${YELLOW}INFO${RESET}] Modifying $drive... HANG TIGHT!!!${NEWLINE}"
        sleep 3
        ls /sys/firmware/efi
        if [[ -d "/sys/firmware/efi" ]]; then
            echo -e "[${YELLOW}INFO${RESET}] UEFI System Detected!${NEWLINE}"
            echo ${NEWLINE}
            sleep 2
            # https://superuser.com/a/984637
            sed -e 's/\s*\([\+0-9a-zA-Z]*\).*/\1/' <<EOF | fdisk $drive
            g # Create new GPT Partition
            n # New partition
            p # Primary partition
            1 # First partition
                # EFI - start at beginning of disk
            +512M # /boot/EFI
            n
            p
            2
                # SWAP - start immediately after preceding partition
            +8G
            n 
            p
            3
                # ROOT, start immediately after preceding partition
                # default, use rest of disk space
            t # change part type
            3 # part number
            83 # linux FS
            p # print the in-memory table
            w # write changes to disk
            q # quit
EOF
            # Format partitions
            if [[ -d /sys/class/nvme ]]; then
                if [[ $diskEncrypt == 'y' ]] || [[ $diskEncrypt == 'Y' ]]; then
                    partition_and_encrypt
                    # Mount partitions
                    mount /dev/mapper/root /mnt
                else
                    BOOT="1"
                    SWAP="2"
                    HOME="3"
                    HOMEDRIVE="$drive$HOME"
                    mkfs.ext4 "$HOMEDRIVE"
                    # Mount partitions
                    mount "$HOMEDRIVE" /mnt
                    # Create swap space
                    SWAPDRIVE="$drive$SWAP"
                    mkswap "$SWAPDRIVE"
                    swapon "$SWAPDRIVE"
                    # Setup EFI Dir
                    BOOTDRIVE="$drive$BOOT"
                    mkfs.fat -F32 "$BOOTDRIVE"
                    mkdir -p /mnt/boot/EFI
                    mount "$BOOTDRIVE" /mnt/boot/EFI
                fi
            else
                echo -e "${YELLOW}[*] BIOS was determined!${RESET}" 
                echo ""
                # Create partitions thru fdisk...
                # https://superuser.com/a/984637
                sed -e 's/\s*\([\+0-9a-zA-Z]*\).*/\1/' <<EOF | fdisk $drive
                o # Clear the in-memory partition table
                n # New partition
                p # Primary partition
                1 # First partition
                    # BIOS - start at beginning of disk
                +8G # /SWAP
                n 
                p
                2
                    # ROOT, start immediately after preceding partition
                    # default, use rest of disk space
                t # change part type
                2 # part number
                83 # linux FS
                p # print the in-memory table
                w # write changes to disk
                q # quit
EOF
                if [[ $diskEncrypt == 'y' ]] || [[ $diskEncrypt == 'Y' ]]; then
                    partition_and_encrypt
                    # Mount partitions
                    mount /dev/mapper/cryptroot /mnt
                    # Create swap space           
                else
                    # Format partitions
                    SWAP="1"
                    HOME="2"
                    HOMEDRIVE="$drive$HOME"
                    mkfs.ext4 "$HOMEDRIVE"
                    # Mount partitions
                    mount "$HOMEDRIVE" /mnt
                    # Create swap space
                    SWAPDRIVE="$drive$SWAP"
                    mkswap "$SWAPDRIVE"
                    swapon "$SWAPDRIVE"
                fi
            fi
        fi
    fi
}



lastMinSetup() {
	#Finish last minute setup
	echo ${NEWLINE}
	echo ${NEWLINE}
	echo 0 > /proc/sys/kernel/hung_task_timeout_secs
	curl -O 'https://raw.githubusercontent.com/ChaoticHackingNetwork/Harch/main/hArchPost'
	chmod +x hArchPost
	mv hArchPost /mnt
	echo ${NEWLINE}
	echo -e "[${YELLOW}INFO${RESET}] Time to enter CHROOT"
	echo -e "[${YELLOW}INFO${RESET}] The final script has been installed and move to your new root directory"
	echo -e "[${YELLOW}INFO${RESET}] Run these commands to finish setup"
	echo ${NEWLLINE}
	echo ${NEWLLINE}
	echo -e "${GREEN}[1] arch-chroot /mnt"
	echo -e "[2] ./hArchPost${RESET}"
	echo ${NEWLINE}
}

greet
sleep 5
clear
checkNet
sleep 5
clear
getDrive
sleep 5
clear
installer
sleep 5
clear
lastMinSetup
